create table "public"."message_files" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "file_path" text not null,
    "message_id" uuid not null
);


alter table "public"."message_files" enable row level security;

create table "public"."messages" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "sender_id" uuid not null,
    "content" text not null,
    "reply_message_id" uuid,
    "group_id" bigint not null
);


alter table "public"."messages" enable row level security;

CREATE UNIQUE INDEX message_files_pkey ON public.message_files USING btree (id);

CREATE UNIQUE INDEX messages_pkey ON public.messages USING btree (id);

alter table "public"."message_files" add constraint "message_files_pkey" PRIMARY KEY using index "message_files_pkey";

alter table "public"."messages" add constraint "messages_pkey" PRIMARY KEY using index "messages_pkey";

alter table "public"."message_files" add constraint "message_files_message_id_fkey" FOREIGN KEY (message_id) REFERENCES messages(id) not valid;

alter table "public"."message_files" validate constraint "message_files_message_id_fkey";

alter table "public"."messages" add constraint "messages_group_id_fkey" FOREIGN KEY (group_id) REFERENCES groups(id) not valid;

alter table "public"."messages" validate constraint "messages_group_id_fkey";

alter table "public"."messages" add constraint "messages_reply_message_id_fkey" FOREIGN KEY (reply_message_id) REFERENCES messages(id) not valid;

alter table "public"."messages" validate constraint "messages_reply_message_id_fkey";

alter table "public"."messages" add constraint "messages_sender_id_fkey" FOREIGN KEY (sender_id) REFERENCES profiles(id) not valid;

alter table "public"."messages" validate constraint "messages_sender_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.post_message(content text, file_paths text[], reply_message_id uuid)
 RETURNS SETOF messages
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
message_id uuid;
file_path text;
BEGIN
  INSERT INTO messages(sender_id, group_id, content, reply_message_id)
  VALUES(auth.uid(), (SELECT group_id FROM profiles u WHERE u.id=auth.uid() LIMIT 1), content, reply_message_id)
  RETURNING id into message_id;

  FOREACH file_path IN ARRAY file_paths
  LOOP
    INSERT INTO message_files(message_id, file_path)
    VALUES(message_id, file_path);
  END LOOP;

  RETURN QUERY
  SELECT *
  FROM messages
  WHERE id = message_id;
  END;
$function$
;

create policy "Enable reading own group's message files"
on "public"."message_files"
as permissive
for select
to authenticated
using ((EXISTS ( SELECT 1
   FROM ((profiles u
     LEFT JOIN profiles o ON ((u.group_id = o.group_id)))
     LEFT JOIN messages m ON ((m.sender_id = o.id)))
  WHERE ((u.id = auth.uid()) AND (m.id = message_files.message_id)))));


create policy "Enable reading own group's messages"
on "public"."messages"
as permissive
for select
to authenticated
using ((EXISTS ( SELECT 1
   FROM (profiles u
     LEFT JOIN profiles o ON ((u.group_id = o.group_id)))
  WHERE ((u.id = auth.uid()) AND (o.id = messages.sender_id)))));



create policy "Enable reading own group's message files"
on "storage"."objects"
as permissive
for select
to authenticated
using (((bucket_id = 'messageFiles'::text) AND (EXISTS ( SELECT 1
   FROM (profiles u
     LEFT JOIN profiles o ON ((u.group_id = o.group_id)))
  WHERE ((u.id = auth.uid()) AND (o.id = objects.owner))))));


create policy "Enable uploading message files for logged in users"
on "storage"."objects"
as permissive
for insert
to authenticated
with check (((bucket_id = 'messageFiles'::text) AND (owner = auth.uid())));



