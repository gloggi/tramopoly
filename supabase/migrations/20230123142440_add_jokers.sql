create table "public"."joker_visits" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "group_id" bigint not null,
    "joker_id" bigint not null,
    "proof_photo_path" text,
    "accepted_at" timestamp with time zone,
    "rejected_at" timestamp with time zone,
    "operator_comment" text,
    "earned_bonus_value" smallint
);


alter table "public"."joker_visits" enable row level security;

create table "public"."jokers" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "name" text not null,
    "value" smallint not null,
    "challenge" text,
    "bonus_call_value" smallint
);


alter table "public"."jokers" enable row level security;

CREATE UNIQUE INDEX joker_visits_pkey ON public.joker_visits USING btree (id);

CREATE UNIQUE INDEX jokers_pkey ON public.jokers USING btree (id);

alter table "public"."joker_visits" add constraint "joker_visits_pkey" PRIMARY KEY using index "joker_visits_pkey";

alter table "public"."jokers" add constraint "jokers_pkey" PRIMARY KEY using index "jokers_pkey";

alter table "public"."joker_visits" add constraint "joker_visits_group_id_fkey" FOREIGN KEY (group_id) REFERENCES groups(id) not valid;

alter table "public"."joker_visits" validate constraint "joker_visits_group_id_fkey";

alter table "public"."joker_visits" add constraint "joker_visits_joker_id_fkey" FOREIGN KEY (joker_id) REFERENCES jokers(id) not valid;

alter table "public"."joker_visits" validate constraint "joker_visits_joker_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.visit_joker(joker_id bigint, proof_photo_path text, group_id bigint)
 RETURNS SETOF joker_visits
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
      BEGIN
          RETURN QUERY
          INSERT INTO joker_visits(joker_id, group_id, proof_photo_path)
          VALUES(joker_id, CASE WHEN role_for(auth.uid())='player' THEN (SELECT u.group_id FROM profiles u WHERE u.id=auth.uid() LIMIT 1) ELSE group_id END, proof_photo_path)
          RETURNING *;
      END;
  $function$
;


create policy "Enable full access for admins"
on "public"."joker_visits"
as permissive
for all
to authenticated
using ((role_for(auth.uid()) = 'admin'::text))
with check ((role_for(auth.uid()) = 'admin'::text));


create policy "Enable reading own group's joker visits"
on "public"."joker_visits"
as permissive
for select
to authenticated
using ((group_id = ( SELECT u.group_id
   FROM profiles u
  WHERE (u.id = auth.uid()))));


create policy "Enable full access for admins"
on "public"."jokers"
as permissive
for all
to authenticated
using ((role_for(auth.uid()) = 'admin'::text))
with check ((role_for(auth.uid()) = 'admin'::text));


create policy "Enable reading for authenticated users only"
on "public"."jokers"
as permissive
for select
to authenticated
using (true);


set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.accessible_to(station_visits)
 RETURNS bigint[]
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN ARRAY[$1.group_id] || (SELECT array_agg(our_visit.group_id)
                                FROM station_visits our_visit
                                WHERE (our_visit.station_id = $1.station_id)
                                  AND (our_visit.accepted_at IS NOT NULL)
                                  AND (our_visit.rejected_at IS NULL)
                                  AND (our_visit.needs_verification = false)
                                  AND (our_visit.verified_at IS NOT NULL)
                                GROUP BY our_visit.station_id);
END
$function$
;

create or replace view "public"."chat_contents" as  SELECT messages.id,
    messages.created_at,
    messages.group_id,
    ARRAY[messages.group_id] AS accessible_to,
    'message'::text AS type
   FROM messages
UNION ALL
 SELECT sv.id,
    sv.created_at,
    sv.group_id,
    accessible_to(sv.*) AS accessible_to,
    'stationVisit'::text AS type
   FROM station_visits sv
UNION ALL
 SELECT jv.id,
    jv.created_at,
    jv.group_id,
    ARRAY[jv.group_id] AS accessible_to,
    'jokerVisit'::text AS type
   FROM joker_visits jv;

